178x3600 -- Tamaño de la Base de Datos


/*
    Lector * lector = Lector::getInstance();
    lector->LeerTxt();
    vector<vector<double>> data= lector->getDatos();
    double suma = 0.0;
    double res = 0.0;
    vector<double> pos = {0,0,1,0,1};
    for (int i = 1; i < data.size(); i++){
        for (int j = 0; j< data.at(i).size(); j++){
            if (pos[j] == 1){
                cout << "Paso " << i << " " << j << endl;
                double dis = data[0][j] - data[i][j];
                suma += dis*dis;
                cout << "Distancia: " << dis << "\tSuma: " << suma << endl;
            }
            
        }
        
        suma = sqrt(suma);
        res += suma;
        suma = 0.0;
        cout << "Resultado: " << res << "\n" << endl;
    }
*/

/*double Particula::calcularValor(){
    vector<vector<double>> data = lector->getDataTest();
    double suma = 0.0;
    double res = 0.0;
    //cout << "Data size: " << data.size() << endl;
    for (int i = 1; i < data.size(); i++){
        //cout << "Primer for" << endl;
        for (int j = 0; j< data.at(i).size(); j++){
            //cout << "Segundo for" << endl;
            //cout << "Pos size " << pos.size() << endl;
            if (pos[j] == 1){
               // cout << "Paso " << i << " " << j << endl;
                double dis = data[0][j] - data[i][j];
                suma += dis*dis;
                //cout << "Distancia: " << dis << "\tSuma: " << suma << endl;
            }
            
        }
        
        suma = sqrt(suma);
        res += suma;
        suma = 0.0;
        //cout << "Resultado: " << res << "\n" << endl;
    }

    return res;
}*/

/*vector<vector<double>> data_test = lector->getDataTest();
    vector<vector<double>> data_training = lector->getDataTraining();
    vector<int> labels_test = lector->getLabelsTest();
    vector<int> labels_training = lector->getLabelsTraining();
    */


Se clasifican todas las filas de test comparando las distancias a todas las filas de training. 
Comprobamos aciertos y errores. 
Acc = Aciertos/Total * 100

Parametros
-nP Numero de particulas
-nH Numero de hebras
-nI Numero MAX de iteraciones
-cS Valor del componente social
-cC Valor del componente cognitivo
-cI Valor del componente inercia
-k  Valor de la componente K

Probar K entre 15 y 25
K = sqrt numero de muestras

probar con Optimización O2 y sin optimización y con o sin simd

Hacer gráfica: 
eje x numero de hebras (1 a 8)
eje y tiempo de ejecucion (en segundos)
secuencial
secuencial O2
paralelo O2 sin simd
paralelo O2 con simd
paralelo sin O2 con simd
paralelo sin O2 sin simd

barrido de K

5 mediciones por muestra



https://efficomp.ugr.es/research/apply-to-use-our-computing-resources/



Hacer un barrido manteniendo 100 iteraciones: usando 15,30,45... hasta 90 partículas (tasa de clasificacion media en cada iteracion)

eje x: numero de iteraciones
eje y: tasa media

mirar seminario 1 de AC

repetir tablas de tiempo con la nueva configuración


Probar alternativas (velocidad)

repetir sin variar el k sqrt(178) con 200P

sacar KNN a secas con sqrt(178) = 13

- KNN
- Repetir con las distintas funciones de movimiento (200p) k=sqrt(178)

Mejores K = 3, 13, 18, 20, 23


Dudas:
- Tiene sentido que la máquina master valore tambien las partículas
- Podría lanzar la máquina master como maestro y esclavo simultáneamente


-D NFEATURES 3600


-- MPI GECCO 2018
-- Master GECCO 2020


make -j N_FEATURES=3600

mpirun --bind-to none --map-by node --host localhost,localhost ./pso
mpirun --bind-to none -np 1 ./pso

- El índice debe estar numerado
- Ya tienes una subsección de validación, por lo que la palabra validación sobra en todas las subsubsecciones de las que cuelga
- En el índice: "Trabajo realizado" -> "Caso de estudio"


y conforme vayas escribiendo ocúpate de los warnings, overfull y underful de Látex. Especialmente los warnings amarillos y los overfull

los badness 10000 suele ser que manualmente metes un \\ donde no pega


https://manualdelatex.com/tutoriales
https://manualdelatex.com/simbolos#chapter10

Introducción:
    Motivación 
    Objetivos (coger del propósito)
        Versión paralela 
        Analisis del tiempo


Cambiar paralelización: primero nodos después CPU

Hablar de PSO, después BPSO, después KNN

\setalgcapfontsize

multiplicacion \cdot

CAP 2: Background

PSO
BPSO
KNN
Estado del arte
Encefalografía

Tesis de Diego Ariel Aquino

claves hpmoon:
user: jlopez
pass: pra57jit8

salloc -N2 -n1 -p guest -w compute-0-2,compute-0-4 mpiexec -x OMP_NUM_THREADS=16 ./holaMundo

-N nodos
-n CPU
-p cola
-w nombres
-x OMP_NUM_THREADS=16 sirve para indicar a OpenMP mediante variable de entorno cuántas hebras quieras.

