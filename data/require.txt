178x3600 -- Tamaño de la Base de Datos


/*
    Lector * lector = Lector::getInstance();
    lector->LeerTxt();
    vector<vector<double>> data= lector->getDatos();
    double suma = 0.0;
    double res = 0.0;
    vector<double> pos = {0,0,1,0,1};
    for (int i = 1; i < data.size(); i++){
        for (int j = 0; j< data.at(i).size(); j++){
            if (pos[j] == 1){
                cout << "Paso " << i << " " << j << endl;
                double dis = data[0][j] - data[i][j];
                suma += dis*dis;
                cout << "Distancia: " << dis << "\tSuma: " << suma << endl;
            }
            
        }
        
        suma = sqrt(suma);
        res += suma;
        suma = 0.0;
        cout << "Resultado: " << res << "\n" << endl;
    }
*/

/*double Particula::calcularValor(){
    vector<vector<double>> data = lector->getDataTest();
    double suma = 0.0;
    double res = 0.0;
    //cout << "Data size: " << data.size() << endl;
    for (int i = 1; i < data.size(); i++){
        //cout << "Primer for" << endl;
        for (int j = 0; j< data.at(i).size(); j++){
            //cout << "Segundo for" << endl;
            //cout << "Pos size " << pos.size() << endl;
            if (pos[j] == 1){
               // cout << "Paso " << i << " " << j << endl;
                double dis = data[0][j] - data[i][j];
                suma += dis*dis;
                //cout << "Distancia: " << dis << "\tSuma: " << suma << endl;
            }
            
        }
        
        suma = sqrt(suma);
        res += suma;
        suma = 0.0;
        //cout << "Resultado: " << res << "\n" << endl;
    }

    return res;
}*/

/*vector<vector<double>> data_test = lector->getDataTest();
    vector<vector<double>> data_training = lector->getDataTraining();
    vector<int> labels_test = lector->getLabelsTest();
    vector<int> labels_training = lector->getLabelsTraining();
    */


Se clasifican todas las filas de test comparando las distancias a todas las filas de training. 
Comprobamos aciertos y errores. 
Acc = Aciertos/Total * 100

Parametros
-nP Numero de particulas
-nH Numero de hebras
-nI Numero MAX de iteraciones
-cS Valor del componente social
-cC Valor del componente cognitivo
-cI Valor del componente inercia
-k  Valor de la componente K

Probar K entre 15 y 25
K = sqrt numero de muestras

probar con Optimización O2 y sin optimización y con o sin simd

Hacer gráfica: 
eje x numero de hebras (1 a 8)
eje y tiempo de ejecucion (en segundos)
secuencial
secuencial O2
paralelo O2 sin simd
paralelo O2 con simd
paralelo sin O2 con simd
paralelo sin O2 sin simd

barrido de K

5 mediciones por muestra



https://efficomp.ugr.es/research/apply-to-use-our-computing-resources/



Hacer un barrido manteniendo 100 iteraciones: usando 15,30,45... hasta 90 partículas (tasa de clasificacion media en cada iteracion)

eje x: numero de iteraciones
eje y: tasa media

mirar seminario 1 de AC

repetir tablas de tiempo con la nueva configuración


Probar alternativas (velocidad)

repetir sin variar el k sqrt(178) con 200P

sacar KNN a secas con sqrt(178) = 13

- KNN
- Repetir con las distintas funciones de movimiento (200p) k=sqrt(178)

Mejores K = 3, 13, 18, 20, 23


Dudas:
- Tiene sentido que la máquina master valore tambien las partículas
- Podría lanzar la máquina master como maestro y esclavo simultáneamente



